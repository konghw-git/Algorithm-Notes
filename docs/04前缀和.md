# 04前缀和

## 1 算法解决的问题、效率及使用条件

- 问题
  - 计算闭区间[left, right]的子数组的元素和

- 复杂度
  - 1的时间复杂度就可以计算出来
- 使用条件
  - 整数数组

## 2 算法的核心思想

有一个数组 `a`  长度为`n`

对于数组`a` 计算它的长度为n+1的前缀和数值`s` 即`a`的前0个数和, 前1个数和, 前2个数和...前n个数的和

`s[0] = 0`

`s[1] = a[0]`

`s[2] = a[0] + a[1]`

...

`s[n] = a[0] + a[1] + ... + a[n-1]`

由此可得

- 前`i`个数的和加上`a[i]`就是前`i+1`个数的和
  - `s[i+1] = s[i] + a[i]`

**通过前缀和可以把数组的元素和转化为两个前缀和的差** 

- 下标区间`[left, right]`的元素和等于前缀`[0, right]`的元素和减去另一个前缀`[0, left-1]`的元素和
  - 即`s[right + 1] - s[left]`
    - 比如 `[-2, 0, 3, -5, 2, -1]`
    - 索引 `[0, 1, 2, 3, 4, 5]`
    - 求`[1, 3]`闭区间的元素和
    - 答案是`s[4]  - s[1]`

> 定义`s[0]` 为 0 是因为 当left为0时 减去前0个元素的和之间减去s[0]即可 不用单独考虑了 如果a是空数组 这个写法也兼容

## 3 算法的步骤与细节

```python
class NumArray:

    def __init__(self, nums: List[int]):
        s = [0] * (len(nums) + 1)
        for i, x in enumerate(nums):
            s[i + 1] = s[i] + x
        self.s = s

    def sumRange(self, left: int, right: int) -> int:
        return self.s[right + 1] - self.s[left]
```



## 4 算法的拓展与变种

1. 求和为k的子数组个数
