# 二分查找——红蓝染色法

## 1 算法解决的问题、效率及使用条件

- 解决问题——处理有序列表查找
  - 统计有序整数数组中某个数(target)出现的次数 
  - 获取有序整数数组中某个数(target)出现的开始位置和结束位置 
  - 统计有序整数数组中大于等于（大于/小于等于/小于）某个数(target)的元素个数  
- 算法效率
  - 把时间复杂度从 n 优化到了 logn
- 使用条件
  - ==**单调性是前提！！！**==
    - **mid点处判断左右染色情况**
  
  - 整数数组
  - 非递减排序
  - target也是整数
  

## 2 算法的核心思想

- 返回有序数组中第一个 >= target 的元素的下标 如果所有的数都不满足条件 最终返回数组长度

  - 也可以说是第一个染成蓝色的下标

  - 大于(第一个大于target的坐标)

    - 转化为 >= target + 1

  - 小于(最后一个小于target的坐标)

    - 转化为(>=target) - 1

  - 小于等于(最后一个小于等于target的坐标)

    - 转化为(>target) -1

  - > 大于/大于等于是求第一个元素坐标——小于/小于等于是求最后一个元素坐标

- 所有的问题都可以基于这个原理解决

## 3 算法步骤细节

```python
from bisect import bisect_left, bisect_right


# 1 手动实现 闭区间版本[left, right]
def count_lower(nums, target):
	left = 0
    right = len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] >= target:
            right = mid - 1
        else:
            left = mid + 1
    return left

# 2 内置函数 左闭右开版本[left, right)
def bisect_left(a, x, lo=0, hi=None):
    """返回在有序列表a中插入x的第一个位置，保持有序性"""
    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo + hi) // 2
        if a[mid] < x:
            lo = mid + 1
        else:
            hi = mid
    return lo


def bisect_right(a, x, lo=0, hi=None):
    """返回在有序列表a中插入x的最后一个位置，保持有序性"""
    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo + hi) // 2
        if a[mid] <= x:
            lo = mid + 1
        else:
            hi = mid
    return lo
```

- `bisect_right(a, x)` 与 `bisect_left(a, x+1)` 的结果是**一致的**  当 `x` 是整数且列表中元素为整数时，两者结果完全相同。
- 前者是返回数组中**大于等于x的最后一个元素下标的下一个**
- 后者是返回数组中**大于等于x+1的第一个元素的下标**
- ==二分有两种类型，越大越是 true 和越小越是 true，越大越是 true这种返回 left 是对的，反过来的越小越是 true，返回值有些区别。==
  - **越大越是true就是当mid处满足条件 那么右边肯定都满足**
    - **当mid处不满足条件 那么左边一定都不满足**
    - **这种情况返回left**

  - **越小越是true就是当mid处满足条件 左边一定满足**
    - **当mid处不满足条件 那么右边一定不满足**
    - **这种情况返回right**


> 1. 我习惯采用闭区间[left, right]方式 ：
> 2. 每次迭代都要关注未知的部分 往未知的地方缩小left 或 right
> 3. 更新left后 要满足left - 1 一定不符合要求 
> 4. 更新right后 要满足right + 1 一定符合要求
> 5. 当数组长度为偶数时 mid即(left + right) // 2表示中间两个元素的左边那个  

## 4 算法拓展与变种

### 4-1 常规变形

- 获取左右边界统计恰好等于某一元素的个数即出现频率时 原始的找值也可以变成找索引
  - 由于排序复杂度是nlogn 对于频繁查找每次都要排序的场景就不适用了
  - 可以避免排序！妙！
  - 还是查询数的问题 只不过数变成了索引


```python
from collections import defaultdict
from bisect import bisect_left, bisect_right

# 1 传统算法 时间复杂度n
class RangeFreqQuery:

    def __init__(self, arr: List[int]):
        self.arr = arr

    def query(self, left: int, right: int, value: int) -> int:
        return self.arr[left:right+1].count(value)

# 2 使用排序+二分查找 算法复杂度nlogn? 因为要排序！ 如果存在大量查询操作，频繁的排序会导致性能瓶颈
class RangeFreqQuery:
    def __init__(self, arr: List[int]):
        self.arr = arr
        
    def count_lower(self, nums, target, left=None, right=None):
        if not (left and right):
            left = 0
            right = len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1
        return left

    def query(self, left: int, right: int, value: int) -> int:
        sorted_segment = sorted(self.arr[left:right+1])
        index1 = self.count_lower(sorted_segment, value)
        index2 = self.count_lower(sorted_segment, value + 1)
        return index2 - index1
        
# 2 优化 把每次查询的复杂度降低至logn 适合高频查询场景
class RangeFreqQuery:
    def __init__(self, arr: List[int]):
        # 把统计value出现的频率转换成索引出现的频率 找值-->找索引值即可
        # 而该方法记录的索引是天然有序的 ！！
        self.positions = defaultdict(list)
        for idx, num in enumerate(arr):
            self.positions[num].append(idx)  # 存储每个值的所有索引（天然有序）
        
    def query(self, left: int, right: int, value: int) -> int:
        if value not in self.positions:
            return 0
        pos = self.positions[value]
        # 找到左边界和右边界
        l = bisect_left(pos, left)
        r = bisect_right(pos, right)
        return r - l        
           
'''
假设原数组是 [1, 3, 2, 3, 5, 3, 4]，那么 self.positions 存储的是：
{
  1: [0],
  3: [1, 3, 5],  # 3在原数组中出现的所有索引（按顺序排列）
  2: [2],
  5: [4],
  4: [6]
}
'''
```

### 4-2 拓展变形(深刻理解红蓝染色法)

#### 1 不排序找峰值

#### 2 旋转数组找最小值

#### 3 旋转数组找target值

> 1. **关键是单调性 左边染成红色 右边染成蓝色 找到染色的条件判断方法**
> 2. **以上三种都是越大越true 返回left（闭区间写法）**

#### 4 寻找两个正序数组的中位数 

- 转化为中位数把数组分割成两个长度相等的部分（奇数数组第一个会多一个元素）
- 由分割后第一个数组的元素最大值 <= 第二个数组元素最小值来二分
- 闭区间写法注意边界问题 即-1处溢出 和+1的末尾溢出问题
- 多思考


------
## 补充知识点 1 ——向上取整与向下取整

- a * b >= success 这个式子 我要转化成 b >= success / a 但是在在代码里面会有取整的问题 如何解决？

### 问题分析
当 `a` 和 `success` 都是整数时，直接计算 `success / a` 会进行整数除法（例如在 Python 中使用 `//` 或其他语言的默认整数除法），这会截断小数部分。例如：
- 若 `success = 7`，`a = 3`，则 `success / a = 2.333...`
- 正确的 `b` 应满足 `b >= 2.333...`，即 `b >= 3`
- 但整数除法会得到 `2`，导致错误地认为 `b >= 2` 即可（此时 `3*2=6 < 7`，不满足原不等式）

### 解决方案
需要通过数学方法规避整数除法的截断问题，确保计算出的 `b` 最小值满足原不等式。正确的转换公式应为：

```
b >= ceil(success / a)
```

其中 `ceil()` 是向上取整函数。在代码中可通过以下方式实现：

#### 1. 使用向上取整函数
大部分编程语言都有内置的向上取整函数（如 Python 的 `math.ceil()`）：

```python
import math

a = 3
success = 7
min_b = math.ceil(success / a)  # 结果为 3
print(min_b)  # 输出：3，满足 3*3=9 >=7
```

#### 2. 不依赖库函数的实现（整数运算）
如果不想引入数学库，可通过整数运算实现向上取整：

```python
a = 3
success = 7
min_b = (success + a - 1) // a  # 等价于 ceil(7/3) = 3
print(min_b)  # 输出：3
```
##### 关键思路：用「补值」抵消截断的影响 妙！！！
为了让整数除法的结果等价于「向上取整」，我们可以在被除数 `success` 上**补一个值**，使得原本会被截断的小数部分「进位」为整数 1。

这个「补值」就是 `a-1`，原因如下：
1. 当 `success` 能被 `a` 整除时（如 `6/3`）：**补值会被整除截断**
   - 补值后：`6 + 3 - 1 = 8` 
   - 整数除法：`8 // 3 = 2`（结果正确，仍为 2）
2. 当 `success` 不能被 `a` 整除时（如 `7/3`）：**补值会使得结果多了1 等同于向上取整** 
   - 补值后：`7 + 3 - 1 = 9`
   - 整数除法：`9 // 3 = 3`（结果正确，由 2.333... 向上取整为 3）

### 实际应用

- 咒语与药水配对问题中 对于每个咒语 要找与该咒语配对成功的药水数目 成功的条件是咒语*药水值大于等于success
- 传统想法：遍历每个咒语 然后对药水列表每个元素相乘后的列表进行二分查找 这样空间复杂度太大
- 优化：遍历每个咒语 然后直接二分查找 把[咒语] * [药水] >= target 转化成 [药水] >= 向上取整(target / [咒语])
  - 找符合要求的药水数目

## 补充知识点2——字典的键

在 Python 中，获取字典的键（keys）可以通过以下几种常用方式操作：

1. **使用 `dict.keys()` 方法**  
   该方法返回一个字典所有键的视图对象（`dict_keys`），可以直接遍历或转换为列表。
   ```python
   my_dict = {'name': 'Alice', 'age': 30, 'city': 'New York'}
   
   # 获取键的视图对象
   keys_view = my_dict.keys()
   print(keys_view)  # 输出：dict_keys(['name', 'age', 'city'])
   
   # 转换为列表（如需修改或索引访问）
   keys_list = list(my_dict.keys())
   print(keys_list)  # 输出：['name', 'age', 'city']
   ```

2. **直接遍历字典**  
   对字典进行 `for` 循环时，默认遍历的是键。
   ```python
   for key in my_dict:
       print(key)  # 依次输出：name, age, city
   ```

3. **使用 `list()` 直接转换字典**  
   将字典直接传入 `list()` 函数，会返回包含所有键的列表（效果等同于 `list(dict.keys())`）。
   ```python
   keys = list(my_dict)
   print(keys)  # 输出：['name', 'age', 'city']
   ```

### 注意事项：
- 字典的键视图（`dict_keys`）是动态的，当字典发生修改时，视图会自动更新。
- Python 3.7+ 中，字典保持插入顺序，因此获取的键也会按插入顺序返回；3.6 及以下版本不保证顺序。

### 实际应用

- 如果需要判断某个键是否存在，可直接使用 `in` 关键字（无需先获取所有键）：
  ```python
  print('age' in my_dict)  # 输出：True
  ```
