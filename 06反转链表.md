# 算法名称

## 1 算法解决的问题、效率及使用条件

1. 链表整体反转
   - 无需哨兵节点
   - 给出头节点`head`
   - 时间复杂度n

2. 链表部分反转
   - 需要哨兵节点
   - 给的left 和 right 位置 都要用到
     - 交换链表中几个连续的元素就操作几次
     - pre最终是交换的片段的开头 cur是pre.next
     - 需要None充当一个哨兵作用

   - 时间复杂度n

3. 链表k个一组反转
   - 思路：
     - 基于部分反转 不断更新p0位置循环 同时判断剩余元素个数大于等于k


## 2 算法的核心思想

- 

## 3 算法的步骤与细节

- 

## 4 算法的拓展与变种

小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点 head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。